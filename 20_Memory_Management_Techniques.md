# Memory Management Techniques | Contiguous Memory Allocation

## 1. Role of Memory in a Multi-programming Environment

In a multi-programming environment, the system keeps multiple processes in main memory at the same time (usually in the ready queue) to ensure high CPU utilization and better responsiveness for users.

If only one process is kept in memory, the CPU would remain idle during that process's I/O or waiting state. However, when multiple processes are loaded in memory, the CPU can switch to another process when one process is waiting, ensuring the CPU stays busy and system performance improves.

## 2. What is Memory Sharing?

In multi-programming, multiple processes share the same physical main memory. This means the operating system must allocate different sections of the physical memory to different processes.

Therefore, the operating system is responsible for **memory management** — deciding which process will be stored in which part of the memory, how allocation will happen, and how the memory will be protected.

## 3. Logical Address vs Physical Address Space

This is a fundamental concept in memory management. Let’s understand it clearly:

### a. Logical Address

The logical address is the address generated by the CPU when a process is executing.  
It is essentially the address of instructions or data that the process requires.

From the programmer’s or user’s perspective, only logical addresses exist. Logical addresses are virtual; they do **not** correspond to actual physical memory locations.

The range in which logical addresses can be generated is called the **logical address space** (for example, from 0 to a maximum value).

### b. Physical Address

The physical address is the actual location in the physical memory unit where data or instructions are stored.

This address exists inside the memory hardware itself.

Users or programs cannot access physical addresses directly; they interact only with logical addresses.

The range of physical addresses is called the **physical address space**.

The physical address is calculated by the **Memory Management Unit (MMU)**.

Generally, the physical address range goes from (Base + 0) to (Base + maximum), where the **Base** value comes from a register called the **relocation register**.

### c. How does Address Mapping Work?

At runtime, when a program generates a logical address, it needs to be translated into a physical address. This translation is done by hardware called the **Memory Management Unit (MMU)**.

The program behaves as if it is working on its own logical address space, but behind the scenes, the system maps these logical addresses to the actual physical memory locations to execute instructions.

## 4. How Does the OS Isolate and Protect Memory? (Memory Mapping and Protection)

The OS controls memory access for each process to ensure that one process cannot interfere with another process's memory or the OS's own memory. This is done through:

- Providing each process with a separate **Virtual Address Space (VAS)** — meaning each process sees its own logical address range.
- Defining legal address boundaries for each process and ensuring the process can only access addresses within its own range.

To implement this, the system uses two special registers:

- **Relocation Register (Base Register):** Stores the starting physical address of the process in main memory (for example, 100040).
- **Limit Register:** Defines the size or range of logical addresses the process is allowed to use (for example, 74600).

The MMU dynamically maps logical addresses to physical addresses by adding the relocation register value.

When the CPU scheduler picks a process for execution, the dispatcher loads the correct relocation and limit register values during a **context switch**.

Every logical address generated by the CPU is checked against the limit register. If the logical address exceeds this limit, an error is raised.

This mechanism provides **memory protection**. If a user program tries to access OS memory or another user process’s memory, the OS traps this illegal access and treats it as a fatal error.

## 5. Address Translation Explained

When a program accesses a logical address, the MMU adds the relocation register's value to it to compute the actual physical address.

This process is called **address translation**.

It allows processes to operate within their own logical address space while the system maps them to different parts of physical memory, providing flexibility and security.

---

## Summary

- In a multi-programming environment, multiple processes reside in memory simultaneously to maximize CPU utilization.
- Each process generates **logical addresses** (virtual addresses), but actual data/instructions reside at **physical addresses** in memory.
- The **Memory Management Unit (MMU)** translates logical addresses to physical addresses using the relocation register.
- The OS uses **relocation and limit registers** to ensure that processes access only their own memory space.
- If a process attempts illegal memory access, the OS traps the error to protect system stability.
- This way, the OS isolates and protects memory, maintaining boundaries between user programs and the operating system itself.

---

# Allocation Method on Physical Memory: Contiguous Memory Allocation

When allocating processes in physical memory, there are two main methods:

- Contiguous Allocation  
- Non-contiguous Allocation  

Here, we will focus only on **Contiguous Memory Allocation**.

---

## 1. What is Contiguous Memory Allocation?

In this scheme, each process is allocated a single continuous block of memory. This means that the space assigned to a process is connected and sequential, with no gaps between the memory locations.

---

## 2. Fixed Partitioning (A Type of Contiguous Allocation)

In fixed partitioning, the main memory is divided into partitions. These partitions can either be of equal size or different sizes.

---

## 3. Limitations of Fixed Partitioning

### a. Internal Fragmentation

Internal fragmentation occurs when the size of a process is smaller than the size of the partition allocated to it. The unused space inside that partition is wasted.

For example, if a partition size is 100 KB and the process size is 70 KB, then 30 KB of memory inside that partition remains unused and wasted. This wasted space cannot be used by other processes.

---

### b. External Fragmentation

External fragmentation happens when the system has enough total free space, but it is scattered in small blocks across the memory rather than being continuous.

Because the free space is not contiguous, a large process cannot be loaded into memory even though there is enough total free memory.

---

### c. Limitation on Process Size

If a process is larger than the size of the largest partition, it cannot be loaded into memory.

This means there is an upper limit on process size which is equal to the size of the largest partition available.

Processes larger than that cannot be accommodated.

---

### d. Low Degree of Multiprogramming

Fixed partitioning limits the number of processes that can be in memory at the same time.

Since partitions are fixed in size and cannot be adjusted dynamically, sometimes memory is wasted when a process uses less space than its partition.

Because of this wasted space, fewer processes can fit into memory simultaneously, which lowers the degree of multiprogramming.

---

## Summary

In contiguous memory allocation, each process is assigned a continuous block of memory. Fixed partitioning divides memory into fixed-size partitions to allocate these blocks.

However, this method faces several problems such as:

- **Internal fragmentation:** wasted space inside partitions when processes are smaller than partition sizes.  
- **External fragmentation:** free memory scattered in small chunks, preventing large processes from loading.  
- **Process size limitation:** processes larger than the biggest partition cannot be loaded.  
- **Low degree of multiprogramming:** inefficient use of memory leading to fewer processes in memory simultaneously.

These limitations reduce the overall efficiency and flexibility of memory management in this scheme.

---

# Dynamic Partitioning

Dynamic Partitioning is a memory allocation technique where the partition size is not fixed in advance. Unlike fixed partitioning, memory is not divided into small, fixed partitions beforehand. Instead, when a process needs to be loaded, a partition is allocated dynamically according to the size of that process.

---

## Features of Dynamic Partitioning

- The partition size is decided dynamically, meaning each process gets exactly as much memory as it requires.
- Memory is not divided into fixed-size partitions, which gives greater flexibility.

---

## Advantages over Fixed Partitioning

### No Internal Fragmentation

Since the partition size is exactly equal to the process size, all allocated memory is fully used. This means there is no internal fragmentation or wasted space inside the partition.

---

### No Limit on Process Size

There is no fixed upper limit on the size of processes because partitions are created based on the size of each process.

Any large process can be loaded into memory as long as there is enough continuous free space available.

---

### Better Degree of Multiprogramming

Since partitions are created dynamically, memory utilization is more efficient.

More processes can be kept in memory simultaneously, which increases the degree of multiprogramming.

---

## Limitation of Dynamic Partitioning

### External Fragmentation

As processes are loaded and removed, small free blocks of memory become scattered throughout the memory space.

Even if there is enough total free memory, it may not be in a single continuous block large enough for a big process.

This situation is called external fragmentation.

In other words, free memory exists but is not continuous, so a large process cannot be loaded.

---

## Example to Understand External Fragmentation

Suppose you have 1000 KB of memory. 

- First, a process of 300 KB arrives and is allocated 300 KB.
- Then, a process of 200 KB arrives and is allocated 200 KB.
- Later, a process of 400 KB arrives, but there is no continuous free block of 400 KB available.

Even if the total free memory is enough, the 400 KB process cannot be loaded because the free spaces are scattered in smaller blocks.

This is an example of external fragmentation.

---

## Summary

In dynamic partitioning, partition sizes are created dynamically according to process sizes. This eliminates internal fragmentation, removes any fixed limit on process size, and improves multiprogramming by efficient memory use.

However, dynamic partitioning suffers from external fragmentation, as small free blocks become scattered in memory, making it difficult to allocate large contiguous blocks to processes.

---